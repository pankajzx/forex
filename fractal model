// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © mindyourbuisness

// Based on HTF Candles by Fadi
// Enhanced with T-spot detection, sweep logic, and TTFM labeling system

//@version=6
indicator("Fractal Model (TTrades)", shorttitle = "TTFM°", overlay = true, max_bars_back = 5000, max_boxes_count = 500, max_lines_count = 500)


//HTF Candle Start


import mindyourbuisness/CustomAlertLib/3 as CAL

// Alert Settings
alertFormat = input.text_area('{"ticker":"{ticker}", "interval":"{interval}", "alert":"{default}"}', "Custom alert message format", group="Alert Settings")


TEMPLATE_COLOR = input.color(color.white, "Template Color", group="HTF Candle")
// Line Styles
var string LINE_STYLE_SOLID = line.style_solid
var string LINE_STYLE_DASHED = line.style_dashed
var string LINE_STYLE_DOTTED = line.style_dotted

// Text Sizes
var string SIZE_TINY = size.tiny
var string SIZE_SMALL = size.small
var string SIZE_NORMAL = size.normal
var string SIZE_LARGE = size.large
var string SIZE_HUGE = size.huge


type Candle
    float           o
    float           c
    float           h
    float           l
    int             o_idx
    int             c_idx
    int             h_idx
    int             l_idx
    box             body
    line            wick_up
    line            wick_down

type Trace
    line            o
    line            c
    line            h
    line            l
    label           o_l
    label           c_l
    label           h_l
    label           l_l

type Imbalance
    box             b
    int             idx

type CandleSettings
    bool            show
    string          htf
    int             max_display

type Settings
    int             max_sets
    color           bull_body
    color           bull_border
    color           bull_wick
    color           bear_body
    color           bear_border
    color           bear_wick
    int             offset
    int             buffer
    int             htf_buffer
    int             width
    bool            trace_show
    color           trace_o_color
    string          trace_o_style
    int             trace_o_size
    color           trace_c_color
    string          trace_c_style
    int             trace_c_size
    color           trace_h_color
    string          trace_h_style
    int             trace_h_size
    color           trace_l_color
    string          trace_l_style
    int             trace_l_size
    string          trace_anchor
    bool            label_show
    color           label_color
    string          label_size
    bool            htf_label_show
    color           htf_label_color
    string          htf_label_size
    bool            htf_timer_show
    color           htf_timer_color
    string          htf_timer_size
    bool            htf_line_show
    color           htf_line_color
    int             htf_line_width
    string          htf_line_style
    int             midline_width
    bool            show_chart_sweeps

type CandleSet
    Candle[]        candles
    Imbalance[]     imbalances
    CandleSettings  settings
    label           tfName
    label           tfTimer
    line[]          htf_starts

type Helper
    string name             = "Helper"

Settings settings           = Settings.new()



var CandleSettings SettingsHTF1 = CandleSettings.new()
var CandleSettings SettingsHTF2 = CandleSettings.new()


var Candle[] candles_1        = array.new<Candle>(0)
var Candle[] candles_2        = array.new<Candle>(0)


var CandleSet htf1          = CandleSet.new()
htf1.settings               := SettingsHTF1
htf1.candles                := candles_1
htf1.htf_starts            := array.new<line>()

var CandleSet htf2          = CandleSet.new()
htf2.settings               := SettingsHTF2
htf2.candles                := candles_2
htf2.htf_starts            := array.new<line>()



//+------------------------------------------------------------------------------------------------------------+//
//+--- Settings                                                                                             ---+//
//+------------------------------------------------------------------------------------------------------------+//

// HTF Selection - Auto or Custom
htf_mode = input.string("Auto", "HTF Mode", options=["Auto", "Custom"], group="HTF Candle")
custom_htf = input.timeframe("1W", "Custom Timeframe", group="HTF Candle")
tspot_bias = input.string("None", "T-Spot Bias", options=["None", "Bullish", "Bearish"], group="HTF Candle")

htf1.settings.show          := input.bool(true, "Show HTF", group="HTF Candle")
htf1.settings.max_display   := input.int(4, "Max Display", group="HTF Candle")
use_actual_day_change       = input.bool(false, "Use Actual Day Change for Daily HTF", group="HTF Candle", tooltip="When enabled, uses dayofmonth() comparison instead of ta.change() for daily timeframe detection")

// Auto HTF Detection Logic
htf_1 = if htf_mode == "Auto"
    if timeframe.period == "1"
        "15"
    else if timeframe.period == "3"
        "30"
    else if timeframe.period == "5"
        "60"
    else if timeframe.period == "15"
        "240"
    else if timeframe.period == "30" or timeframe.period == "60"
        "1D"
    else if timeframe.period == "240" or timeframe.period == "480"
        "1W"
    else if timeframe.period == "1D"
        "1M"
    else
        "1W"  // Default fallback
else
    custom_htf

htf1.settings.htf := htf_1

htf2.settings.show          := false

settings.max_sets           := 1

settings.bull_body       := input.color(color.new(#8ABF91, 10), "Body  ", inline="body", group="HTF Candle")
settings.bear_body       := input.color(color.new(#E08C89, 10), "", inline="body", group="HTF Candle")
settings.bull_border     := input.color(color.new(#8ABF91, 10), "Borders", inline="borders", group="HTF Candle")
settings.bear_border     := input.color(color.new(#E08C89, 10), "", inline="borders", group="HTF Candle")
settings.bull_wick       := input.color(color.new(#8ABF91, 10), "Wick  ", inline="wick", group="HTF Candle")
settings.bear_wick       := input.color(color.new(#E08C89, 10), "", inline="wick", group="HTF Candle")

settings.offset          := input.int(20, "padding from current candles", minval = 1, group="HTF Candle")
settings.buffer          := input.int(1, "space between candles", minval = 1, maxval = 4, group="HTF Candle")
settings.htf_buffer      := input.int(5, "space between Higher Timeframes", minval = 1, maxval = 10, group="HTF Candle")
settings.width           := input.int(1, "Candle Width", minval = 1, maxval = 4, group="HTF Candle")*2

settings.htf_label_show  := input.bool(true, "HTF Label           ", inline="HTFlabel", group="HTF Candle")
settings.htf_label_color := input.color(color.black, "", inline='HTFlabel', group="HTF Candle")
settings.htf_label_size  := input.string(SIZE_NORMAL, "", [SIZE_TINY, SIZE_SMALL, SIZE_NORMAL, SIZE_LARGE, SIZE_HUGE], inline="HTFlabel", group="HTF Candle")

settings.htf_timer_show  := input.bool(true, "Remaining time      ", inline="timer", group="HTF Candle")
settings.htf_timer_color := input.color(color.black, "", inline='timer', group="HTF Candle")
settings.htf_timer_size  := input.string(SIZE_NORMAL, "", [SIZE_TINY, SIZE_SMALL, SIZE_NORMAL, SIZE_LARGE, SIZE_HUGE], inline="timer", group="HTF Candle")

// Table display settings
show_table = input.bool(true, "Show Info Table", group="HTF Candle")
table_position = input.string("Top Right", "Table Position", options=["Top Left", "Top Center", "Top Right", "Middle Left", "Middle Center", "Middle Right", "Bottom Left", "Bottom Center", "Bottom Right"], group="HTF Candle")
table_bg_color = input.color(color.new(color.gray, 100), "Table Background", group="HTF Candle")
table_border_color = input.color(color.black, "Table Border", group="HTF Candle")
table_text_color = input.color(color.black, "Table Text", group="HTF Candle")
table_size = input.string(SIZE_SMALL, "Table Text Size", options=[SIZE_TINY, SIZE_SMALL, SIZE_NORMAL, SIZE_LARGE, SIZE_HUGE], group="HTF Candle")
table_border_width = input.int(1, "Table Border Width", minval=0, maxval=5, group="HTF Candle")
table_frame_color = input.color(color.black, "Table Frame Color", group="HTF Candle")
table_frame_width = input.int(1, "Table Frame Width", minval=0, maxval=5, group="HTF Candle")


settings.trace_show      := input.bool(false, "Trace lines", group="HTF Candle")
settings.trace_o_color   := input.color(color.new(color.gray, 50), "Open    ", inline='1', group="HTF Candle")
settings.trace_o_style   := input.string(LINE_STYLE_DOTTED, '', options = [LINE_STYLE_SOLID, LINE_STYLE_DASHED, LINE_STYLE_DOTTED], inline='1', group="HTF Candle")
settings.trace_o_size    := input.int(1, '', options = [1,2,3,4], inline='1', group="HTF Candle")
settings.trace_c_color   := input.color(color.new(color.gray, 50), "Close    ", inline='2', group="HTF Candle")
settings.trace_c_style   := input.string(LINE_STYLE_DOTTED, '', options = [LINE_STYLE_SOLID, LINE_STYLE_DASHED, LINE_STYLE_DOTTED], inline='2', group="HTF Candle")
settings.trace_c_size    := input.int(1, '', options = [1,2,3,4], inline='2', group="HTF Candle")
settings.trace_h_color   := input.color(color.new(color.gray, 50), "High     ", inline='3', group="HTF Candle")
settings.trace_h_style   := input.string(LINE_STYLE_DOTTED, '', options = [LINE_STYLE_SOLID, LINE_STYLE_DASHED, LINE_STYLE_DOTTED], inline='3', group="HTF Candle")
settings.trace_h_size    := input.int(1, '', options = [1,2,3,4], inline='3', group="HTF Candle")
settings.trace_l_color   := input.color(color.new(color.gray, 50), "Low     ", inline='4', group="HTF Candle")
settings.trace_l_style   := input.string(LINE_STYLE_DOTTED, '', options = [LINE_STYLE_SOLID, LINE_STYLE_DASHED, LINE_STYLE_DOTTED], inline='4', group="HTF Candle")
settings.trace_l_size    := input.int(1, '', options = [1,2,3,4], inline='4', group="HTF Candle")
settings.trace_anchor    := input.string("First Timeframe", "Anchor to", options=["First Timeframe", "Last Timeframe"], group="HTF Candle")


settings.htf_line_show   := input.bool(true, "HTF Start Line    ", inline="htfline", group="HTF Candle")
settings.htf_line_color  := input.color(color.black, "", inline="htfline", group="HTF Candle")
settings.htf_line_width  := input.int(1, "", options=[1,2,3], inline="htfline", group="HTF Candle")
settings.htf_line_style  := input.string(LINE_STYLE_DOTTED, "", options=[LINE_STYLE_SOLID, LINE_STYLE_DASHED, LINE_STYLE_DOTTED], inline="htfline", group="HTF Candle")

settings.show_chart_sweeps := input.bool(true, "Show Chart Sweeps", inline="sweeps", group="HTF Candle")
// show_tspot = input.bool(true, "Show T-Spot", inline="tspot", group="HTF Candle")
show_only_latest_tspot = input.bool(true, "Show Only Latest T-Spot", inline="tspot2", group="HTF Candle")
show_only_latest_sweep = input.bool(false, "Show Only Latest Sweep", inline="tspot2", group="HTF Candle")
show_tspot_sweeps = input.bool(true, "Show T-Spot Sweeps", inline="tspot_sweeps", group="HTF Candle")
// tspot_sweep_label_color = input.color(color.white, "| Sweep Label Color", inline="tspot_sweeps", group="HTF Candle")
tspot_sweep_label_size = input.string(SIZE_TINY, "Label Size", options=[SIZE_TINY, SIZE_SMALL, SIZE_NORMAL, SIZE_LARGE, SIZE_HUGE ], inline="tspot_sweeps", group="HTF Candle")
show_confirmation_lines = show_tspot_sweeps
show_confirmation_labels = show_tspot_sweeps
// show_confirmation_lines = input.bool(true, "Show Confirmation Lines", inline="tspot_sweeps", group="HTF Candle")
// show_confirmation_labels = input.bool(true, "Show Confirmation Labels", inline="tspot_sweeps", group="HTF Candle")
confirmation_line_style = input.string(LINE_STYLE_SOLID, "Confirmation Line Style", options=[LINE_STYLE_SOLID, LINE_STYLE_DASHED, LINE_STYLE_DOTTED], inline="tspot", group="HTF Candle")
show_ttfm_labels = input.bool(true, "Show TTFM Labels", inline="ttfm", group="HTF Candle")
ttfm_label_size = input.string(SIZE_SMALL, "TTFM Label Size", options=[SIZE_TINY, SIZE_SMALL, SIZE_NORMAL, SIZE_LARGE, SIZE_HUGE], inline="ttfm", group="HTF Candle")

// CISD and Projections Settings
show_cisd = input.bool(true, "Show CISD Lines", group="CISD & Projections")
cisd_color = input.color(color.yellow, "CISD Line Color", group="CISD & Projections")
cisd_width = input.int(2, "CISD Line Width", minval=1, maxval=5, group="CISD & Projections")
show_projections = input.bool(true, "Show Projections", group="CISD & Projections")
projection_color = input.color(color.gray, "Projection Color", group="CISD & Projections")
projection_levels = input.string("0.5,1.0,1.5,2.0", "Projection Levels (comma-separated)", group="CISD & Projections")
extend_latest_projections = input.bool(true, "Extend Latest Projections to Current Bar", group="CISD & Projections")
projection_label_size = input.string(SIZE_TINY, "Projection Label Size", options=[SIZE_TINY, SIZE_SMALL, SIZE_NORMAL, SIZE_LARGE, SIZE_HUGE], group="CISD & Projections")
tspot_line_style = input.string(LINE_STYLE_SOLID, "T-Spot Line Style", options=[LINE_STYLE_SOLID, LINE_STYLE_DASHED, LINE_STYLE_DOTTED], inline="tspot", group="HTF Candle")
tspot_transparency = input.int(90, "T-Spot Transparency", minval=0, maxval=100, inline="tspot", group="HTF Candle")
settings.midline_width := input.int(1, "Midline Width", minval=1, maxval=4, inline="tspot", group="HTF Candle")
show_silver_tspot = input.bool(true, "Show Silver T-Spot", inline="silver_tspot", group="HTF Candle")

hide_against_tspots = input.bool(true, "Hide T-Spots When Trading Against", inline="silver_tspot", group="HTF Candle")
delete_against_tspots = input.bool(false, "Delete T-Spots When Trading Against", inline="silver_tspot", group="HTF Candle")

var line[] htf_lines = array.new_line(0)
var box[] tspot_boxes = array.new_box(0)
var line[] tspot_midlines = array.new_line(0)
var line[] tspot_closelines = array.new_line(0)
var line[] sweep_lines = array.new_line(0)
var line[] midpoint_lines = array.new_line(0)
var label[] c2_labels = array.new_label(0)
var label[] c3_labels = array.new_label(0)
var line[] confirmation_lines = array.new_line(0)

// Table element
var table info_table = na

// T-spot sweep confirmation tracking
var bool tspot_touched = false
var string tspot_type = ""
var float tspot_level = 0.0
var int touch_bar = 0
var int last_tspot_start_bar = 0
var float last_pivot_high = na
var float last_pivot_low = na
var int last_pivot_high_bar = 0
var int last_pivot_low_bar = 0

// Latest confirmed sweep signal data for position sizing
var float latest_entry_price = na
var float latest_stop_price = na
var string latest_signal_type = ""
var float latest_position_size = na

// Track table dimensions
var int current_table_rows = 3


// Function to find bar index where level was formed
findLevelBarIndex(target_level, max_bars_back) =>
    var int found_bar = 0
    for i = 0 to max_bars_back
        if high[i] == target_level or low[i] == target_level
            found_bar := bar_index - i
            break
    found_bar



// Projection arrays for extension management
var array<line> projection_lines = array.new<line>()
var array<label> projection_labels = array.new<label>()

// Complete CISD and Projections system - no arrays
detectCISDAndProjections(int c2_bar, float c2_extreme_level, bool is_bullish, int end_bar) =>
    
    // Find the series by going back from C2 bar until polarity changes
    series_high = c2_extreme_level
    series_low = c2_extreme_level
    series_count = 0
    
    // Always include the C2 bar in the series (it can be as little as 1 candle)
    series_count := 1
    
    // Go back from C2 bar until polarity changes
    for i = 1 to 20
        check_bar = c2_bar - i
        if check_bar < 0
            break
        
        // Check candle polarity
        is_bullish_candle = close[bar_index - check_bar] > open[bar_index - check_bar]
        
        if is_bullish
            // For bullish T-spot, we want down candles (bearish candles)
            if not is_bullish_candle
                series_high := math.max(series_high, high[bar_index - check_bar])
                series_low := math.min(series_low, low[bar_index - check_bar])
                series_count += 1
            else
                break
        else
            // For bearish T-spot, we want up candles (bullish candles)
            if is_bullish_candle
                series_high := math.max(series_high, high[bar_index - check_bar])
                series_low := math.min(series_low, low[bar_index - check_bar])
                series_count += 1
            else
                break
    
    // Look forward from C2 bar to find where series breaks
    series_broken = false
    break_bar = 0
    
    // Check from C2 bar forward to current bar
    for i = 0 to (bar_index - c2_bar)
        check_bar = c2_bar + i
        if check_bar > bar_index
            break
        
        if is_bullish
            // For bullish T-spot, check if price closed above series high
            if close[bar_index - check_bar] > series_high
                series_broken := true
                break_bar := check_bar
                break
        else
            // For bearish T-spot, check if price closed below series low
            if close[bar_index - check_bar] < series_low
                series_broken := true
                break_bar := check_bar
                break
    
    // If series was broken, draw CISD line and projections
    if series_broken
        // Draw CISD line if enabled
        if show_cisd
            // CISD line is horizontal from last bar in series to break point
            series_extreme = is_bullish ? series_high : series_low  // For bullish: series high, for bearish: series low
            // Find the last bar in the series (furthest back from C2)
            last_series_bar = c2_bar - (series_count - 1)
            line.new(last_series_bar, series_extreme, break_bar, series_extreme, color=cisd_color, style=line.style_solid, width=cisd_width)
        
        // Draw projections if enabled
        if show_projections
            series_range = series_high - series_low
            
            // Only draw projections if series range is not 0
            if series_range > 0
                break_price = is_bullish ? series_high : series_low
                
                // Parse projection levels from user input
                levels = str.split(projection_levels, ",")
                for i = 0 to array.size(levels) - 1
                    level_str = str.trim(array.get(levels, i))
                    if level_str != ""
                        level = str.tonumber(level_str)
                        if not na(level)
                            // For bullish: project UP from break price, for bearish: project DOWN from break price
                            proj_price = is_bullish ? break_price + (series_range * level) : break_price - (series_range * level)
                            
                            // Draw line from break_bar to bar_index (or end_bar if not extending)
                            line_end = extend_latest_projections ? bar_index : end_bar
                            proj_line = line.new(bar_index, proj_price, line_end, proj_price, color=projection_color, style=line.style_dotted, width=1)
                            proj_label = label.new(bar_index, proj_price, str.tostring(level), color=color.new(color.white, 100), textcolor=projection_color, style=label.style_label_right, size=projection_label_size, text_font_family=font.family_monospace)
                            
                            // Store in arrays for extension management
                            array.unshift(projection_lines, proj_line)
                            array.unshift(projection_labels, proj_label)

//+------------------------------------------------------------------------------------------------------------+//
//+--- Variables                                                                                            ---+//
//+------------------------------------------------------------------------------------------------------------+//

Helper    helper        = Helper.new()
var Trace trace         = Trace.new()
color color_transparent = #ffffff00

//+------------------------------------------------------------------------------------------------------------+//
//+--- Internal Functions                                                                                   ---+//
//+------------------------------------------------------------------------------------------------------------+//

method LineStyle(Helper helper, string style) =>
    helper.name := style
    out = switch style
        '----' => line.style_dashed
        '····' => line.style_dotted
        => line.style_solid


method ValidTimeframe(Helper helper, string HTF) =>
    helper.name := HTF
    if timeframe.in_seconds(HTF) >= timeframe.in_seconds("1D") and timeframe.in_seconds(HTF) > timeframe.in_seconds()
        true
    else
        n1 = timeframe.in_seconds()
        n2 = timeframe.in_seconds(HTF)
        n3 = n1 % n2
        (n1 < n2 and math.round(n2/n1) == n2/n1)


method RemainingTime(Helper helper, string HTF) =>
    helper.name     := HTF
    if barstate.isrealtime
        timeRemaining   = (time_close(HTF) - timenow)/1000
        days            = math.floor(timeRemaining / 86400)
        hours           = math.floor((timeRemaining - (days*86400)) / 3600)
        minutes         = math.floor((timeRemaining - (days*86400) - (hours*3600))/ 60)
        seconds         = math.floor(timeRemaining - (days*86400) - (hours*3600) - (minutes*60))

        r = str.tostring(seconds, "00")
        if minutes > 0 or hours > 0 or days > 0
            r := str.tostring(minutes, "00") + ":" + r
        if hours > 0 or days > 0
            r := str.tostring(hours, "00") + ":" + r
        if days > 0
            r := str.tostring(days) + "D " + r
        r
    else
        "n/a"

method HTFName(Helper helper, string HTF) =>
    helper.name := "HTFName"
    formatted = HTF

    seconds = timeframe.in_seconds(HTF)
    if seconds < 60
        formatted := str.tostring(seconds) + "S"
    else if (seconds / 60) < 60
        formatted := str.tostring((seconds/60)) + "M"
    else if (seconds/60/60) < 24
        formatted := str.tostring((seconds/60/60)) + "H" 
    formatted

method GetCurrentTimeframe(Helper helper) =>
    helper.name := "GetCurrentTimeframe"
    current_seconds = timeframe.in_seconds()
    if current_seconds < 60
        str.tostring(current_seconds) + "S"
    else if (current_seconds / 60) < 60
        str.tostring((current_seconds/60)) + "M"
    else if (current_seconds/60/60) < 24
        str.tostring((current_seconds/60/60)) + "H"
    else
        str.tostring((current_seconds/60/60/24)) + "D"

method GetCurrentBias(Helper helper) =>
    helper.name := "GetCurrentBias"
    if tspot_bias == "Bullish"
        "Bias: Bullish"
    else if tspot_bias == "Bearish"
        "Bias: Bearish"
    else
        "Bias: Neutral"

method GetHTFBias(Helper helper, Candle last_closed, Candle prev_closed) =>
    helper.name := "GetHTFBias"
    
    // Check if we have valid candles
    if na(last_closed) or na(prev_closed)
        "Bias: Neutral"
    else
        last_close = last_closed.c
        prev_close = prev_closed.c
        last_high = last_closed.h
        last_low = last_closed.l
        prev_high = prev_closed.h
        prev_low = prev_closed.l
        last_open = last_closed.o
        
        // Check for sweeps
        swept_high = last_high > prev_high
        swept_low = last_low < prev_low
        
        // Basic cases
        if last_close > prev_high
            "Bias: Bullish"
        else if last_close < prev_low
            "Bias: Bearish"
        // Sweep cases
        else if swept_high and last_close < prev_high
            "Bias: Bearish"
        else if swept_low and last_close > prev_low
            "Bias: Bullish"
        // Inside candle case (no sweeps)
        else if not swept_high and not swept_low
            "Bias: Neutral"
        // Swept both high and low + close within
        else if swept_high and swept_low
            upper_wick = last_high - math.max(last_open, last_close)
            lower_wick = math.min(last_open, last_close) - last_low
            if lower_wick > upper_wick
                "Bias: Bearish"
            else if upper_wick > lower_wick
                "Bias: Bullish"
            else
                "Bias: Neutral"
        else
            "Bias: Neutral"


method GetTablePosition(Helper helper, string position) =>
    helper.name := "GetTablePosition"
    switch position
        'Top Left' => position.top_left
        'Top Center' => position.top_center
        'Top Right' => position.top_right
        'Middle Left' => position.middle_left
        'Middle Center' => position.middle_center
        'Middle Right' => position.middle_right
        'Bottom Left' => position.bottom_left
        'Bottom Center' => position.bottom_center
        'Bottom Right' => position.bottom_right
        => position.top_right

method HTFEnabled(Helper helper) =>
    helper.name := "HTFEnabled"
    int enabled =0
    enabled += htf1.settings.show ? 1 : 0
    enabled += htf2.settings.show ? 1 : 0

    int last = math.min(enabled, settings.max_sets)

    last

method CandleSetHigh(Helper helper, Candle[] candles, float h) =>
    helper.name := "CandlesSetHigh"
    float _h = h
    if array.size(candles) > 0
        for i = 0 to array.size(candles)-1
            Candle c = array.get(candles, i)
            if c.h > _h
                _h := c.h
    _h

method CandlesHigh(Helper helper, Candle[] candles) =>
    helper.name := "CandlesHigh"
    h   = 0.0
    int cnt = 0
    int last = helper.HTFEnabled()

    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        h := helper.CandleSetHigh(htf1.candles, h)
        cnt += 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf2.candles, h)
        cnt +=1
    h

    if array.size(candles) > 0
        for i = 0 to array.size(candles)-1
            Candle c = array.get(candles, i)
            if c.h > h
                h := c.h
    h

method Reorder(CandleSet candleSet, int offset) =>
    size = candleSet.candles.size()

    if size > 0
        for i = size-1 to 0
            Candle candle = candleSet.candles.get(i)
            t_buffer = offset + ((settings.width+settings.buffer)*(size-i-1))
            box.set_left(candle.body, bar_index + t_buffer)
            box.set_right(candle.body, bar_index + settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index+((settings.width)/2) + t_buffer)
            line.set_x2(candle.wick_up, bar_index+((settings.width)/2) + t_buffer)
            line.set_x1(candle.wick_down, bar_index+((settings.width)/2) + t_buffer)
            line.set_x2(candle.wick_down, bar_index+((settings.width)/2) + t_buffer)
    candleSet

    top     = helper.CandlesHigh(candleSet.candles)
    left    = bar_index + offset + ((settings.width+settings.buffer)*(size-1))/2

    if settings.htf_label_show
        var label l = candleSet.tfName

        string lbl = helper.HTFName(candleSet.settings.htf)
        if settings.htf_timer_show
            lbl += "\n"
   
        if not na(l)
            label.set_xy(l, left, top)            
        else
            l := label.new(left, top, lbl, color=color_transparent, textcolor = settings.htf_label_color, style=label.style_label_down, size = settings.htf_label_size, text_font_family=font.family_monospace)

    if settings.htf_timer_show
        string tmr = "(" + helper.RemainingTime(candleSet.settings.htf) + ")"
        if not na(candleSet.tfTimer)
            candleSet.tfTimer.set_xy(left, top)
            candleSet.tfTimer.set_text(tmr)            
        else
            candleSet.tfTimer := label.new(left, top, tmr, color=color_transparent, textcolor = settings.htf_timer_color, style=label.style_label_down, size = settings.htf_timer_size, text_font_family=font.family_monospace)

    if candleSet.htf_starts.size() > 0
        for i = 0 to candleSet.htf_starts.size() - 1
            line l = candleSet.htf_starts.get(i)
            if not na(l)
                t_buffer = offset + ((settings.width+settings.buffer)*(i))
                line.set_x1(l, bar_index + t_buffer)
                line.set_x2(l, bar_index + t_buffer)

    candleSet



// Function to calculate logarithmic midpoint
method calculateLogMidpoint(float high, float low, float open, float close) =>
    float log_high = math.log(high)
    float log_low = math.log(low)
    float log_open = math.log(open)
    float log_close = math.log(close)
    
    float body_size = math.abs(log_close - log_open)
    float upper_wick = log_high - math.max(log_open, log_close)
    float lower_wick = math.min(log_open, log_close) - log_low
    
    float log_mid_level = if math.max(upper_wick, lower_wick) > body_size
        if upper_wick > lower_wick
            log_high - upper_wick/2
        else
            log_low + lower_wick/2
    else
        (log_high + log_low)/2
    
    math.exp(log_mid_level)



method FindImbalance(CandleSet candleSet) =>
    if barstate.isrealtime or barstate.islast
        // Clean up old midpoint lines
        if midpoint_lines.size() > 0
            for i = midpoint_lines.size()-1 to 0
                line.delete(midpoint_lines.pop())
        
        // Clean up old sweep lines
        if sweep_lines.size() > 0
            for i = sweep_lines.size()-1 to 0
                line.delete(sweep_lines.pop())
        

        if candleSet.candles.size() > 3
            // Draw midpoint lines for each closed candle
            for i = 0 to candleSet.candles.size() - 2
                current_candle = candleSet.candles.get(i)  // This is actually the newer candle
                prev_candle = candleSet.candles.get(i + 1)  // This is the older candle
                
                // Calculate midpoint using our function
                float mid_level = calculateLogMidpoint(prev_candle.h, prev_candle.l, prev_candle.o, prev_candle.c)
                
                // Draw dotted line from older candle to newer candle and store it
                midpoint_line = line.new(box.get_left(prev_candle.body) + settings.width/2, mid_level,box.get_left(current_candle.body) + settings.width/2, mid_level,color=TEMPLATE_COLOR, width=1, style=line.style_dotted)
                midpoint_lines.unshift(midpoint_line)
            // Original sweep checks
            for i = 0 to candleSet.candles.size() - 2
                current_candle = candleSet.candles.get(i)
                next_candle = candleSet.candles.get(i + 1)
                
                // High sweep - current candle's high breaks next candle's high but closes below it
                if current_candle.h > next_candle.h and current_candle.c < next_candle.h
                    sweep_line = line.new(box.get_left(next_candle.body) + settings.width/2, next_candle.h, box.get_right(current_candle.body) + settings.width, next_candle.h, color=TEMPLATE_COLOR, width=1)
                    sweep_lines.unshift(sweep_line)
                
                // Low sweep - current candle's low breaks next candle's low but closes above it
                if current_candle.l < next_candle.l and current_candle.c > next_candle.l
                    sweep_line = line.new(box.get_left(next_candle.body) + settings.width/2, next_candle.l, box.get_right(current_candle.body) + settings.width, next_candle.l, color=TEMPLATE_COLOR, width=1)
                    sweep_lines.unshift(sweep_line)

        
        //Clean up excess sweep lines to respect max_display setting
        if sweep_lines.size() > candleSet.settings.max_display
            while sweep_lines.size() > candleSet.settings.max_display
                line.delete(sweep_lines.pop())
        
        // Clean up excess midpoint lines to respect max_display setting  
        if midpoint_lines.size() > candleSet.settings.max_display
            while midpoint_lines.size() > candleSet.settings.max_display
                line.delete(midpoint_lines.pop())
    candleSet


// Get the current bar's hour using exchange time
barHour = hour(time)

// Compute 4H candle block (1 to 6)
candleOfDay = math.floor(barHour / 4) + 1

label_atr = ta.atr(200) / 2

method Monitor(CandleSet candleSet) =>
    HTFBarTime = time(candleSet.settings.htf)
    
    // Use actual day change for daily HTF if toggle is enabled
    isNewHTFCandle = if use_actual_day_change and candleSet.settings.htf == "1D"
        dayofmonth(time) != dayofmonth(time[1])
    else
        ta.change(HTFBarTime) != 0

    // Add label on the current chart bar showing latest T-spot information
    if tspot_boxes.size() > 0
        latest_tspot = tspot_boxes.get(0)
        latest_tspot_mid_line = tspot_midlines.get(0)
        tspot_top = box.get_top(latest_tspot)
        tspot_bottom = box.get_bottom(latest_tspot)
        
        
        // T-spot touch detection and confirmation is handled in main execution flow

    // Extend latest projections if enabled
    if extend_latest_projections and projection_lines.size() > 0
        // Calculate projection count from user input
        levels = str.split(projection_levels, ",")
        projection_count = 0
        for i = 0 to array.size(levels) - 1
            level_str = str.trim(array.get(levels, i))
            if level_str != ""
                projection_count += 1
        
        // Extend only the latest group of projections (latest projection_count lines)
        for i = 0 to math.min(projection_count - 1, array.size(projection_lines) - 1)
            proj_line = array.get(projection_lines, i)
            line.set_x2(proj_line, bar_index)

    // Clean up old projection lines and labels (run every bar)
    levels = str.split(projection_levels, ",")
    projection_count = 0
    for i = 0 to array.size(levels) - 1
        level_str = str.trim(array.get(levels, i))
        if level_str != ""
            projection_count += 1
    
    // if projection_lines.size() > candleSet.settings.max_display * projection_count
    //     old_proj_line = projection_lines.pop()
    //     old_proj_label = projection_labels.pop()
    //     line.delete(old_proj_line)
    //     label.delete(old_proj_label)

    if isNewHTFCandle 
        lineStyle = settings.htf_line_style
        if settings.htf_line_show
            // line newLine = line.new(x1=bar_index, y1=0, x2=bar_index, y2=1, color=settings.htf_line_color, style=lineStyle, width=settings.htf_line_width, extend=extend.both)
            line newLine = line.new(x1=bar_index, y1=low, x2=bar_index, y2=high, color=settings.htf_line_color, style=lineStyle, width=settings.htf_line_width, extend=extend.both)
            htf_lines.unshift(newLine)

        // // Remove excess lines
        // if htf_lines.size() > candleSet.settings.max_display
        //     line oldLine = htf_lines.pop()
        //     line.delete(oldLine)


        // Create new candle
        Candle candle = Candle.new()
        candle.o        := open
        candle.c        := close
        candle.h        := high
        candle.l        := low
        candle.o_idx    := bar_index
        candle.c_idx    := bar_index
        candle.h_idx    := bar_index
        candle.l_idx    := bar_index

        bull = candle.c > candle.o

        candle.body         := box.new(bar_index, math.max(candle.o, candle.c), bar_index+2, math.min(candle.o, candle.c), 
             bull ? settings.bull_border : settings.bear_border, 1, bgcolor = bull ? settings.bull_body : settings.bear_body)
        candle.wick_up      := line.new(bar_index+1, candle.h, bar_index, math.max(candle.o, candle.c), 
             color=bull ? settings.bull_wick : settings.bear_wick)
        candle.wick_down    := line.new(bar_index+1, math.min(candle.o, candle.c), bar_index, candle.l, 
             color=bull ? settings.bull_wick : settings.bear_wick)

        candleSet.candles.unshift(candle)

        if candleSet.candles.size() > candleSet.settings.max_display
            Candle delCandle = array.pop(candleSet.candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)

        // T-spot monitoring logic
        if candleSet.candles.size() >= 4 
            current_candle = candleSet.candles.get(0)   
            last_closed = candleSet.candles.get(1)      
            prev_closed = candleSet.candles.get(2)      
            prev_prev_closed = candleSet.candles.get(3)
            
            latest_line = array.get(htf_lines, 0)
            start_bar = line.get_x2(latest_line)

            oktspot_bearish_bias = tspot_bias == "Bearish" or tspot_bias == "None"
            oktspot_bullish_bias = tspot_bias == "Bullish" or tspot_bias == "None"
            
            if not na(start_bar)
                htf_bars = int(timeframe.in_seconds(htf1.settings.htf) / timeframe.in_seconds())
                end_bar = int(start_bar + htf_bars)
                
                float mid_level = calculateLogMidpoint(prev_closed.h, prev_closed.l, prev_closed.o, prev_closed.c)
                var bool tspot_created = false
                var int last_htf_candle_bar = 0
                
                // Only reset tspot_created when a new HTF candle starts
                if start_bar != last_htf_candle_bar
                    tspot_created := false
                    last_htf_candle_bar := start_bar


                // Bearish T-spot
                if not tspot_created and last_closed.h > prev_closed.h and last_closed.c < prev_closed.h and oktspot_bearish_bias and not (last_closed.h > prev_closed.h and last_closed.l < prev_closed.l and last_closed.c > prev_closed.l and last_closed.c < prev_closed.h)
                    if settings.show_chart_sweeps
                        sweep_line = line.new(box.get_left(prev_closed.body) + settings.width/2, prev_closed.h, box.get_right(current_candle.body), prev_closed.h, color=TEMPLATE_COLOR, width=1)
                        sweep_lines.unshift(sweep_line)
                    
                    sweep_mid = calculateLogMidpoint(last_closed.h, last_closed.l, last_closed.o, last_closed.c)
                    if last_closed.c < sweep_mid
                        box newBox = box.new(start_bar, sweep_mid, end_bar, last_closed.c, 
                             bgcolor=color.new(settings.bear_body, tspot_transparency), 
                             border_color=color.new(color.white, 100))
                        line newMidline = line.new(start_bar, sweep_mid, end_bar, sweep_mid, 
                             color=settings.htf_label_color, 
                             style=tspot_line_style,
                             width=settings.midline_width)
                        line newCloseline = line.new(start_bar, last_closed.c, end_bar, last_closed.c, 
                             color=color.new(color.white, 100))
                        
                        if show_silver_tspot
                            if (candleOfDay == 5 or (candleOfDay == 4 and hour(time, "America/New_York") >= 13)) and last_closed.c < prev_prev_closed.l and last_closed.c < prev_closed.l
                                CAL.customAlert(alertFormat, "Silver Bearish T-Spot on " + syminfo.ticker + " (" + candleSet.settings.htf + ")")
                                label.new(bar_index, high, "Silver T-Spot", color=color.new(color.white, 100), textcolor=settings.bear_body, style=label.style_label_down, size=tspot_sweep_label_size, text_font_family=font.family_monospace)

                        tspot_boxes.unshift(newBox)
                        tspot_midlines.unshift(newMidline)
                        tspot_closelines.unshift(newCloseline)
                        tspot_created := true
                        
                        // C2 and C3 Labels for Bearish T-spot
                        // C2 Label
                        c2_level = last_closed.h  // Protected level from last_closed
                        c2_bar = findLevelBarIndex(last_closed.h, 100)  // Find where this level was formed
                        
                        // CISD Detection for Normal Bearish T-spot
                        if c2_bar > 0
                            detectCISDAndProjections(c2_bar, last_closed.h, false, end_bar)
                        
                        if c2_bar > 0 and show_ttfm_labels
                            c2_label = label.new(c2_bar, c2_level + label_atr, "C2", color=color.new(color.white, 100), textcolor=settings.bear_body, style=label.style_label_down, size=ttfm_label_size, text_font_family=font.family_monospace)
                            array.unshift(c2_labels, c2_label)
                            
                            // C3 Label for normal bearish
                            c3_label = label.new(bar_index, sweep_mid + label_atr, "C3", color=color.new(color.white, 100), textcolor=settings.bear_body, style=label.style_label_down, size=ttfm_label_size, text_font_family=font.family_monospace)
                            array.unshift(c3_labels, c3_label)

                        
                        // if tspot_boxes.size() > candleSet.settings.max_display
                        //     box.delete(tspot_boxes.pop())
                        //     line.delete(tspot_midlines.pop())
                        //     line.delete(tspot_closelines.pop())

                // Bullish T-spot
                if not tspot_created and last_closed.l < prev_closed.l and last_closed.c > prev_closed.l and oktspot_bullish_bias and not (last_closed.h > prev_closed.h and last_closed.l < prev_closed.l and last_closed.c > prev_closed.l and last_closed.c < prev_closed.h)
                    if settings.show_chart_sweeps
                        sweep_line = line.new(box.get_left(prev_closed.body) + settings.width/2, prev_closed.l, box.get_right(current_candle.body), prev_closed.l, color=TEMPLATE_COLOR, width=1)
                        sweep_lines.unshift(sweep_line)
                    
                    sweep_mid = calculateLogMidpoint(last_closed.h, last_closed.l, last_closed.o, last_closed.c)
                    if last_closed.c > sweep_mid
                        box newBox = box.new(start_bar, sweep_mid, end_bar, last_closed.c, 
                             bgcolor=color.new(settings.bull_body, tspot_transparency), 
                             border_color=color.new(color.white, 100))
                        line newMidline = line.new(start_bar, sweep_mid, end_bar, sweep_mid,
                             color=settings.htf_label_color,
                             style=tspot_line_style,
                             width=settings.midline_width)
                        line newCloseline = line.new(start_bar, last_closed.c, end_bar, last_closed.c,
                             color=color.new(color.white, 100))


                        if show_silver_tspot
                            if (candleOfDay == 5 or (candleOfDay == 4 and hour(time, "America/New_York") >= 13)) and last_closed.c > prev_prev_closed.h and last_closed.c > prev_closed.h
                                CAL.customAlert(alertFormat, "Silver Bullish T-Spot on " + syminfo.ticker + " (" + candleSet.settings.htf + ")")
                                label.new(bar_index, low, "Silver T-Spot", color=color.new(color.white, 100), textcolor=settings.bear_body, style=label.style_label_down, size=tspot_sweep_label_size, text_font_family=font.family_monospace)
                        
                        tspot_boxes.unshift(newBox)
                        tspot_midlines.unshift(newMidline)
                        tspot_closelines.unshift(newCloseline)
                        tspot_created := true
                        
                        // C2 and C3 Labels for Bullish T-spot
                        
                        // C2 Label
                        c2_level = last_closed.l  // Protected level from last_closed
                        c2_bar = findLevelBarIndex(last_closed.l, 100)  // Find where this level was formed
                        
                        // CISD Detection for Normal Bullish T-spot
                        if c2_bar > 0
                            detectCISDAndProjections(c2_bar, last_closed.l, true, end_bar)
                        
                        if c2_bar > 0 and show_ttfm_labels
                            c2_label = label.new(c2_bar, c2_level - label_atr, "C2", color=color.new(color.white, 100), textcolor=settings.bull_body, style=label.style_label_down, size=ttfm_label_size, text_font_family=font.family_monospace)
                            array.unshift(c2_labels, c2_label)
                            
                            // C3 Label for normal bullish
                            c3_label = label.new(bar_index, sweep_mid - label_atr, "C3", color=color.new(color.white, 100), textcolor=settings.bull_body, style=label.style_label_down, size=ttfm_label_size, text_font_family=font.family_monospace)
                            array.unshift(c3_labels, c3_label)

                        
                        // if tspot_boxes.size() > candleSet.settings.max_display
                        //     box.delete(tspot_boxes.pop())
                        //     line.delete(tspot_midlines.pop())
                        //     line.delete(tspot_closelines.pop())

                // Expansive Bearish T-spot - previous candle swept high, last candle expands and closes below high sweep low
                if not tspot_created and prev_closed.h > prev_prev_closed.h and last_closed.c < math.max(prev_closed.o, prev_closed.c) and oktspot_bearish_bias and not (last_closed.h > prev_closed.h and last_closed.l < prev_closed.l and last_closed.c > prev_closed.l and last_closed.c < prev_closed.h) and ((prev_closed.c >= calculateLogMidpoint(prev_closed.h, prev_closed.l, prev_closed.o, prev_closed.c)) or (prev_closed.c >= prev_prev_closed.h) or (prev_closed.h > prev_prev_closed.h and prev_closed.l < prev_prev_closed.l and prev_closed.c > prev_prev_closed.l and prev_closed.c < prev_prev_closed.h))
                    sweep_mid = calculateLogMidpoint(last_closed.h, last_closed.l, last_closed.o, last_closed.c)
                    if last_closed.c < sweep_mid
                        box newBox = box.new(start_bar, sweep_mid, end_bar, last_closed.c, bgcolor=color.new(settings.bear_body, tspot_transparency), border_color=color.new(color.white, 100))
                        line newMidline = line.new(start_bar, sweep_mid, end_bar, sweep_mid, color=settings.htf_label_color, style=tspot_line_style, width=settings.midline_width)
                        line newCloseline = line.new(start_bar, last_closed.c, end_bar, last_closed.c, color=color.new(color.white, 100))
                        
                        if show_silver_tspot
                            if (candleOfDay == 5 or (candleOfDay == 4 and hour(time, "America/New_York") >= 13)) and last_closed.c < prev_prev_closed.l and last_closed.c < prev_closed.l
                                CAL.customAlert(alertFormat, "Silver Expansive Bearish T-Spot on " + syminfo.ticker + " (" + candleSet.settings.htf + ")")
                                label.new(bar_index, high, "Silver Expansive T-Spot", color=color.new(color.white, 100), textcolor=settings.bear_body, style=label.style_label_down, size=tspot_sweep_label_size, text_font_family=font.family_monospace)

                        tspot_boxes.unshift(newBox)
                        tspot_midlines.unshift(newMidline)
                        tspot_closelines.unshift(newCloseline)
                        tspot_created := true
                        
                        // C2 and C3 Labels for Expansive Bearish T-spot

                            // C2 Label
                        c2_level = prev_closed.h  // Protected level from prev_closed
                        c2_bar = findLevelBarIndex(prev_closed.h, 100)  // Find where this level was formed
                        
                        // CISD Detection for Expansive Bearish T-spot
                        if c2_bar > 0
                            detectCISDAndProjections(c2_bar, prev_closed.h, false, end_bar)

                        if c2_bar > 0 and show_ttfm_labels
                            c2_label = label.new(c2_bar, c2_level + label_atr, "C2", color=color.new(color.white, 100), textcolor=settings.bear_body, style=label.style_label_down, size=ttfm_label_size, text_font_family=font.family_monospace)
                            array.unshift(c2_labels, c2_label)
                            
                            // C4 Label for expansive bearish
                            c4_label = label.new(bar_index, sweep_mid + label_atr, "C4", color=color.new(color.white, 100), textcolor=settings.bear_body, style=label.style_label_down, size=ttfm_label_size, text_font_family=font.family_monospace)
                            array.unshift(c3_labels, c4_label)

                        // if tspot_boxes.size() > candleSet.settings.max_display
                        //     box.delete(tspot_boxes.pop())
                        //     line.delete(tspot_midlines.pop())
                        //     line.delete(tspot_closelines.pop())


                // Expansive Bullish T-spot - previous candle swept low, last candle expands and closes above low sweep high
                if not tspot_created and prev_closed.l < prev_prev_closed.l and last_closed.c > math.min(prev_closed.o, prev_closed.c) and oktspot_bullish_bias and not (last_closed.h > prev_closed.h and last_closed.l < prev_closed.l and last_closed.c > prev_closed.l and last_closed.c < prev_closed.h) and ((prev_closed.c <= calculateLogMidpoint(prev_closed.h, prev_closed.l, prev_closed.o, prev_closed.c)) or (prev_closed.c <= prev_prev_closed.l) or (prev_closed.h > prev_prev_closed.h and prev_closed.l < prev_prev_closed.l and prev_closed.c > prev_prev_closed.l and prev_closed.c < prev_prev_closed.h))
                    sweep_mid = calculateLogMidpoint(last_closed.h, last_closed.l, last_closed.o, last_closed.c)
                    
                    if last_closed.c > sweep_mid
                        box newBox = box.new(start_bar, sweep_mid, end_bar, last_closed.c, bgcolor=color.new(settings.bull_body, tspot_transparency), border_color=color.new(color.white, 100))
                        line newMidline = line.new(start_bar, sweep_mid, end_bar, sweep_mid, color=settings.htf_label_color, style=tspot_line_style, width=settings.midline_width)
                        line newCloseline = line.new(start_bar, last_closed.c, end_bar, last_closed.c, color=color.new(color.white, 100))
                        
                        if show_silver_tspot
                            if (candleOfDay == 5 or (candleOfDay == 4 and hour(time, "America/New_York") >= 13)) and last_closed.c > prev_prev_closed.h and last_closed.c > prev_closed.h
                                CAL.customAlert(alertFormat, "Silver Expansive Bullish T-Spot on " + syminfo.ticker + " (" + candleSet.settings.htf + ")")
                                label.new(bar_index, low, "Silver Expansive T-Spot", color=color.new(color.white, 100), textcolor=settings.bull_body, style=label.style_label_up, size=tspot_sweep_label_size, text_font_family=font.family_monospace)

                        tspot_boxes.unshift(newBox)
                        tspot_midlines.unshift(newMidline)
                        tspot_closelines.unshift(newCloseline)
                        tspot_created := true
                        
                        // C2 and C3 Labels for Expansive Bullish T-spot
                        
                        // C2 Label
                        c2_level = prev_closed.l  // Protected level from prev_closed
                        c2_bar = findLevelBarIndex(prev_closed.l, 100)  // Find where this level was formed
                        
                        // CISD Detection for Expansive Bullish T-spot
                        if c2_bar > 0
                            detectCISDAndProjections(c2_bar, prev_closed.l, true, end_bar)
                        
                        if c2_bar > 0 and show_ttfm_labels
                            c2_label = label.new(c2_bar, c2_level - label_atr, "C2", color=color.new(color.white, 100), textcolor=settings.bull_body, style=label.style_label_down, size=ttfm_label_size, text_font_family=font.family_monospace)
                            array.unshift(c2_labels, c2_label)
                            
                            // C4 Label for expansive bullish
                            c4_label = label.new(bar_index, sweep_mid - label_atr, "C4", color=color.new(color.white, 100), textcolor=settings.bull_body, style=label.style_label_down, size=ttfm_label_size, text_font_family=font.family_monospace)
                            array.unshift(c3_labels, c4_label)

                        // if tspot_boxes.size() > candleSet.settings.max_display
                        //     box.delete(tspot_boxes.pop())
                        //     line.delete(tspot_midlines.pop())
                        //     line.delete(tspot_closelines.pop())


                // Pro-trend bullish midpoint sweep T-spot - simplified
                if not tspot_created and last_closed.l < mid_level and last_closed.l > prev_closed.o and last_closed.c > prev_closed.h and oktspot_bullish_bias and not (last_closed.h > prev_closed.h and last_closed.l < prev_closed.l and last_closed.c > prev_closed.l and last_closed.c < prev_closed.h)
                    sweep_mid = calculateLogMidpoint(last_closed.h, last_closed.l, last_closed.o, last_closed.c)
                    if last_closed.c > sweep_mid
                        box newBox = box.new(start_bar, sweep_mid, end_bar, last_closed.c, 
                             bgcolor=color.new(settings.bull_body, tspot_transparency), 
                             border_color=color.new(color.white, 100))
                        line newMidline = line.new(start_bar, sweep_mid, end_bar, sweep_mid,
                             color=settings.htf_label_color,
                             style=tspot_line_style,
                             width=settings.midline_width)
                        line newCloseline = line.new(start_bar, last_closed.c, end_bar, last_closed.c,
                             color=color.new(color.white, 100))
                        
                        if show_silver_tspot
                            if (candleOfDay == 5 or (candleOfDay == 4 and hour(time, "America/New_York") >= 13)) and last_closed.c > prev_prev_closed.h and last_closed.c > prev_closed.h
                                CAL.customAlert(alertFormat, "Silver Bullish T-Spot on " + syminfo.ticker + " (" + candleSet.settings.htf + ")")
                                label.new(bar_index, low, "Silver T-Spot", color=color.new(color.white, 100), textcolor=settings.bull_body, style=label.style_label_up, size=tspot_sweep_label_size, text_font_family=font.family_monospace)


                        tspot_boxes.unshift(newBox)
                        tspot_midlines.unshift(newMidline)
                        tspot_closelines.unshift(newCloseline)
                        tspot_created := true
                        

                        // if tspot_boxes.size() > candleSet.settings.max_display
                        //     box.delete(tspot_boxes.pop())
                        //     line.delete(tspot_midlines.pop())
                        //     line.delete(tspot_closelines.pop())

                // Pro-trend bearish midpoint sweep T-spot - simplified
                if not tspot_created and last_closed.h > mid_level and last_closed.h < prev_closed.o and last_closed.c < prev_closed.l and oktspot_bearish_bias and not (last_closed.h > prev_closed.h and last_closed.l < prev_closed.l and last_closed.c > prev_closed.l and last_closed.c < prev_closed.h)
                    sweep_mid = calculateLogMidpoint(last_closed.h, last_closed.l, last_closed.o, last_closed.c)
                    if last_closed.c < sweep_mid
                        box newBox = box.new(start_bar, sweep_mid, end_bar, last_closed.c, 
                             bgcolor=color.new(settings.bear_body, tspot_transparency), 
                             border_color=color.new(color.white, 100))
                        line newMidline = line.new(start_bar, sweep_mid, end_bar, sweep_mid,
                             color=settings.htf_label_color,
                             style=tspot_line_style,
                             width=settings.midline_width)
                        line newCloseline = line.new(start_bar, last_closed.c, end_bar, last_closed.c,
                             color=color.new(color.white, 100))
                        
                        if show_silver_tspot
                            if (candleOfDay == 5 or (candleOfDay == 4 and hour(time, "America/New_York") >= 13)) and last_closed.c < prev_prev_closed.l and last_closed.c < prev_closed.l
                                CAL.customAlert(alertFormat, "Silver Bearish T-Spot on " + syminfo.ticker + " (" + candleSet.settings.htf + ")")
                                label.new(bar_index, high, "Silver T-Spot", color=color.new(color.white, 100), textcolor=settings.bear_body, style=label.style_label_down, size=tspot_sweep_label_size, text_font_family=font.family_monospace)

                        tspot_boxes.unshift(newBox)
                        tspot_midlines.unshift(newMidline)
                        tspot_closelines.unshift(newCloseline)
                        tspot_created := true
                        

                        // if tspot_boxes.size() > candleSet.settings.max_display
                        //     box.delete(tspot_boxes.pop())
                        //     line.delete(tspot_midlines.pop())
                        //     line.delete(tspot_closelines.pop())



                // Clear previous T-spots if we only want to show the latest
                if show_only_latest_tspot and tspot_created
                    while tspot_boxes.size() > 1
                        box.delete(tspot_boxes.pop())
                    while tspot_midlines.size() > 1
                        line.delete(tspot_midlines.pop())
                    while tspot_closelines.size() > 1
                        line.delete(tspot_closelines.pop())
                
                // Clean up old TTFM labels if we exceed max_display
                // if c2_labels.size() > candleSet.settings.max_display
                //     while c2_labels.size() > candleSet.settings.max_display
                //         label.delete(c2_labels.pop())
                //         label.delete(c3_labels.pop())
                
                // Clear previous TTFM labels if we only want to show the latest
                if show_only_latest_tspot and (c2_labels.size() > 0 or c3_labels.size() > 0)
                    while c2_labels.size() > 1
                        label.delete(c2_labels.pop())
                    while c3_labels.size() > 1
                        label.delete(c3_labels.pop())
                
                // Sweep lines are now cleaned up in FindImbalance method
                
                // Midpoint lines are now cleaned up in FindImbalance method
    candleSet

method Update(CandleSet candleSet, int offset, bool showTrace) =>
    if candleSet.candles.size() > 0
        Candle candle   = candleSet.candles.first()
        candle.h_idx    := high > candle.h ? bar_index : candle.h_idx
        candle.h        := high > candle.h ? high : candle.h
        candle.l_idx    := low < candle.l ? bar_index : candle.l_idx
        candle.l        := low < candle.l ? low : candle.l
        candle.c        := close
        candle.c_idx   := bar_index

        bull = candle.c > candle.o

        box.set_top(candle.body, candle.o)
        box.set_bottom(candle.body, candle.c)
        box.set_bgcolor(candle.body, bull ? settings.bull_body : settings.bear_body)
        box.set_border_color(candle.body, bull ? settings.bull_border : settings.bear_border)
        line.set_color(candle.wick_up, bull ? settings.bull_wick : settings.bear_wick)
        line.set_color(candle.wick_down, bull ? settings.bull_wick : settings.bear_wick)
        line.set_y1(candle.wick_up, candle.h)
        line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_y1(candle.wick_down, candle.l)
        line.set_y2(candle.wick_down, math.min(candle.o, candle.c))

        if barstate.isrealtime or barstate.islast
            candleSet.Reorder(offset)
            if settings.trace_show and showTrace
                if bar_index - candle.o_idx < 5000
                    if na(trace.o)
                        trace.o := line.new(candle.o_idx, candle.o, box.get_left(candle.body), candle.o, xloc= xloc.bar_index, color=settings.trace_o_color, style= helper.LineStyle(settings.trace_o_style), width=settings.trace_o_size)
                    else
                        line.set_xy1(trace.o, candle.o_idx, candle.o)
                        line.set_xy2(trace.o, box.get_left(candle.body), candle.o)
    
                if bar_index - candle.c_idx < 5000
                    if na(trace.c)
                        trace.c := line.new(candle.c_idx, candle.c, box.get_left(candle.body), candle.c, xloc= xloc.bar_index, color=settings.trace_c_color, style=helper.LineStyle(settings.trace_c_style), width=settings.trace_c_size)
                    else
                        line.set_xy1(trace.c, candle.c_idx, candle.c)
                        line.set_xy2(trace.c, box.get_left(candle.body), candle.c)


                if bar_index - candle.h_idx < 5000
                    if na(trace.h)
                        trace.h := line.new(candle.h_idx, candle.h, line.get_x1(candle.wick_up), candle.h, xloc= xloc.bar_index, color=settings.trace_h_color, style=helper.LineStyle(settings.trace_h_style), width=settings.trace_h_size)
                    else
                        line.set_xy1(trace.h, candle.h_idx, candle.h)
                        line.set_xy2(trace.h, line.get_x1(candle.wick_up), candle.h)


                if bar_index - candle.l_idx < 5000
                    if na(trace.l)
                        trace.l := line.new(candle.l_idx, candle.l, line.get_x1(candle.wick_down), candle.l, xloc= xloc.bar_index, color=settings.trace_l_color, style=helper.LineStyle(settings.trace_l_style), width=settings.trace_l_size)
                    else
                        line.set_xy1(trace.l, candle.l_idx, candle.l)
                        line.set_xy2(trace.l, line.get_x1(candle.wick_down), candle.l)

    candleSet

int cnt = 0
int last = helper.HTFEnabled()

// Pivot detection for T-spot sweep confirmation
pivot_high = ta.pivothigh(high, 1, 2)
pivot_low = ta.pivotlow(low, 1, 2)

// Update latest pivot levels and bars
if not na(pivot_high)
    last_pivot_high := pivot_high
    last_pivot_high_bar := bar_index[2]

if not na(pivot_low)
    last_pivot_low := pivot_low
    last_pivot_low_bar := bar_index[2]

// T-spot touch detection and confirmation
tspot_start_bar = 0
if tspot_boxes.size() > 0
    latest_tspot = tspot_boxes.get(0)
    latest_midline = tspot_midlines.get(0)
    tspot_top = box.get_top(latest_tspot)
    tspot_bottom = box.get_bottom(latest_tspot)
    tspot_start_bar := box.get_left(latest_tspot)
    
    // Reset touch state if T-spot start bar has changed (new T-spot created)
    if tspot_start_bar != last_tspot_start_bar
        tspot_touched := false
    
    // Always update the last T-spot start bar
    last_tspot_start_bar := tspot_start_bar
    
    // Get the midline level from the T-spot
    tspot_midline = line.get_y1(latest_midline)
    
    // Determine T-spot type based on midline position
    tspot_type := tspot_midline >= math.max(tspot_top, tspot_bottom) ? "bearish" : "bullish"
    
    // Touch level depends on T-spot type
    tspot_touch_level = tspot_type == "bearish" ? math.min(tspot_top, tspot_bottom) : math.max(tspot_top, tspot_bottom)
    
    // Check if price touched the appropriate level based on T-spot type
    if tspot_type == "bearish"
        // Bearish T-spot: touch bottom level
        if (high > tspot_touch_level or open > tspot_touch_level) and close < tspot_touch_level
            tspot_touched := true
            tspot_level := tspot_touch_level
            touch_bar := bar_index
    else
        // Bullish T-spot: touch top level
        if (low < tspot_touch_level or open < tspot_touch_level) and close > tspot_touch_level
            tspot_touched := true
            tspot_level := tspot_touch_level
            touch_bar := bar_index


// Check for confirmation sweeps
if tspot_touched and show_tspot_sweeps

    // Bullish T-spot sweep: only for bullish T-spots, pivot high before touch, close above pivot, pivot above touch level
    if tspot_type == "bullish" and not na(last_pivot_high) and last_pivot_high_bar < touch_bar and close > last_pivot_high and  open < last_pivot_high and last_pivot_high > tspot_level
        // Find lowest low between pivot candle and confirmation candle
        lowest_low = low[0]
        for i = 0 to (bar_index - last_pivot_high_bar)
            if low[i] < lowest_low
                lowest_low := low[i]
        
        if show_confirmation_labels
            label.new(bar_index, lowest_low - label_atr, "🟢", color=color.new(color.white, 100), textcolor=color.white, style=label.style_label_down, size=tspot_sweep_label_size, text_font_family=font.family_monospace)
        CAL.customAlert(alertFormat, "Bullish T-Spot Sweep Confirmed on " + syminfo.ticker + " (" + htf1.settings.htf + ")")
        
        if show_confirmation_lines
            // Clear previous confirmation lines
            // if confirmation_lines.size() > 0
            //     for i = 0 to confirmation_lines.size() - 1
            //         line.delete(confirmation_lines.get(i))
            //     array.clear(confirmation_lines)
            
            // Create new confirmation line
            new_confirmation_line = line.new(last_pivot_high_bar, last_pivot_high, bar_index, last_pivot_high, color=settings.bull_body, width=1, style=confirmation_line_style)
            array.push(confirmation_lines, new_confirmation_line)
        
   
        
        // Reset touch tracking
        tspot_touched := false
    

    // Bearish T-spot sweep: only for bearish T-spots, pivot low before touch, close below pivot, pivot below touch level
    if tspot_type == "bearish" and not na(last_pivot_low) and last_pivot_low_bar < touch_bar and close < last_pivot_low and open > last_pivot_low and last_pivot_low < tspot_level
        // Find highest high between pivot candle and confirmation candle
        highest_high = high[0]
        for i = 0 to (bar_index - last_pivot_low_bar)
            if high[i] > highest_high
                highest_high := high[i]
        
        if show_confirmation_labels
            label.new(bar_index, highest_high + label_atr, "🔴", color=color.new(color.white, 100), textcolor=color.white, style=label.style_label_down, size=tspot_sweep_label_size, text_font_family=font.family_monospace)
        CAL.customAlert(alertFormat, "Bearish T-Spot Sweep Confirmed on " + syminfo.ticker + " (" + htf1.settings.htf + ")")
        
        if show_confirmation_lines
            // Clear previous confirmation lines
            // if confirmation_lines.size() > 0
            //     for i = 0 to confirmation_lines.size() - 1
            //         line.delete(confirmation_lines.get(i))
            //     array.clear(confirmation_lines)
            
            // Create new confirmation line
            new_confirmation_line = line.new(last_pivot_low_bar, last_pivot_low, bar_index, last_pivot_low, color=settings.bear_body, width=1, style=confirmation_line_style)
            array.push(confirmation_lines, new_confirmation_line)


        
        // Reset touch tracking
        tspot_touched := false

// Hide T-spots when trading against them
if hide_against_tspots and tspot_boxes.size() > 0
    for i = 0 to tspot_boxes.size() - 1
        current_box = tspot_boxes.get(i)
        current_midline = tspot_midlines.get(i)
        box_top = box.get_top(current_box)
        box_bottom = box.get_bottom(current_box)
        midline_price = line.get_y1(current_midline)
        
        // If bearish T-spot (top > bottom) and price closes above midline
        if box_top > box_bottom and close > midline_price
            box.set_bgcolor(current_box, color.new(color.white, 100))
            box.set_border_color(current_box, color.new(color.white, 100))
            line.set_color(current_midline, color.new(settings.htf_label_color, 100))
        // If bullish T-spot (bottom > top) and price closes below midline
        else if box_bottom > box_top and close < midline_price
            box.set_bgcolor(current_box, color.new(color.white, 100))
            box.set_border_color(current_box, color.new(color.white, 100))
            line.set_color(current_midline, color.new(settings.htf_label_color, 100))
        // Restore original colors when not trading against
        else
            // Determine if it's bearish or bullish T-spot
            if box_top > box_bottom
                // Bearish T-spot - restore bearish colors
                box.set_bgcolor(current_box, color.new(settings.bear_body, tspot_transparency))
                box.set_border_color(current_box, color.new(color.white, 100))
                line.set_color(current_midline, settings.htf_label_color)
            else
                // Bullish T-spot - restore bullish colors
                box.set_bgcolor(current_box, color.new(settings.bull_body, tspot_transparency))
                box.set_border_color(current_box, color.new(color.white, 100))
                line.set_color(current_midline, settings.htf_label_color)

// Delete T-spots that have been traded against (keep only latest in each direction)
if delete_against_tspots and tspot_boxes.size() > 1
    var bool[] bearish_traded_against = array.new<bool>()
    var bool[] bullish_traded_against = array.new<bool>()
    
    // Initialize arrays if needed
    if array.size(bearish_traded_against) != tspot_boxes.size()
        array.clear(bearish_traded_against)
        array.clear(bullish_traded_against)
        for i = 0 to tspot_boxes.size() - 1
            array.push(bearish_traded_against, false)
            array.push(bullish_traded_against, false)
    
    // Check which T-spots have been traded against
    for i = 0 to tspot_boxes.size() - 1
        current_box = tspot_boxes.get(i)
        current_midline = tspot_midlines.get(i)
        box_top = box.get_top(current_box)
        box_bottom = box.get_bottom(current_box)
        midline_price = line.get_y1(current_midline)
        
        // Check if bearish T-spot has been traded against
        if box_top > box_bottom
            // Look back through historical data to see if price ever closed above midline
            traded_against = false
            for j = 0 to 100  // Check last 100 bars
                if bar_index - j >= box.get_left(current_box)
                    if close[j] > midline_price
                        traded_against := true
                        break
            array.set(bearish_traded_against, i, traded_against)
        
        // Check if bullish T-spot has been traded against
        else if box_bottom > box_top
            // Look back through historical data to see if price ever closed below midline
            traded_against = false
            for j = 0 to 100  // Check last 100 bars
                if bar_index - j >= box.get_left(current_box)
                    if close[j] < midline_price
                        traded_against := true
                        break
            array.set(bullish_traded_against, i, traded_against)
    
    // Find latest bearish and bullish T-spots
    latest_bearish_index = -1
    latest_bullish_index = -1
    
    for i = 0 to tspot_boxes.size() - 1
        current_box = tspot_boxes.get(i)
        box_top = box.get_top(current_box)
        box_bottom = box.get_bottom(current_box)
        
        if box_top > box_bottom  // Bearish T-spot
            if latest_bearish_index == -1 or box.get_left(tspot_boxes.get(latest_bearish_index)) < box.get_left(current_box)
                latest_bearish_index := i
        else if box_bottom > box_top  // Bullish T-spot
            if latest_bullish_index == -1 or box.get_left(tspot_boxes.get(latest_bullish_index)) < box.get_left(current_box)
                latest_bullish_index := i
    
    // Delete older T-spots that have been traded against
    for i = tspot_boxes.size() - 1 to 0
        current_box = tspot_boxes.get(i)
        box_top = box.get_top(current_box)
        box_bottom = box.get_bottom(current_box)
        
        should_delete = false
        
        if box_top > box_bottom  // Bearish T-spot
            if i != latest_bearish_index and array.get(bearish_traded_against, i)
                should_delete := true
        else if box_bottom > box_top  // Bullish T-spot
            if i != latest_bullish_index and array.get(bullish_traded_against, i)
                should_delete := true
        
        if should_delete
            // Delete the T-spot and its associated elements
            box.delete(tspot_boxes.get(i))
            line.delete(tspot_midlines.get(i))
            line.delete(tspot_closelines.get(i))
            
            // Remove from arrays
            array.remove(tspot_boxes, i)
            array.remove(tspot_midlines, i)
            array.remove(tspot_closelines, i)
            array.remove(bearish_traded_against, i)
            array.remove(bullish_traded_against, i)

int htf_offset = settings.offset
if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf) and bar_index > last_bar_index - 1000
    bool showTrace = false
    if settings.trace_anchor == "First Timeframe"
        showTrace := true
    if settings.trace_anchor == "Last Timeframe" and settings.max_sets == 1
        showTrace := true
    htf1.Monitor().Update(htf_offset, showTrace).FindImbalance()
    cnt +=1
    htf_offset += cnt > 0 ? (htf1.candles.size() * settings.width) + (htf1.candles.size() > 0 ? (htf1.candles.size()-1) * settings.buffer : 0) +  settings.htf_buffer : 0
// if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
//     bool showTrace = false
//     if settings.trace_anchor == "First Timeframe" and cnt == 0
//         showTrace := true
//     if settings.trace_anchor == "Last Timeframe" and cnt == last-1
//         showTrace := true
//     htf2.Monitor().Update(htf_offset, showTrace).FindImbalance()
//     cnt+=1
//     htf_offset += cnt > 0 ? (htf2.candles.size() * settings.width) + (htf2.candles.size() > 0 ? (htf2.candles.size()-1) * settings.buffer : 0) +  settings.htf_buffer : 0

// Create info table if enabled
if show_table and htf1.candles.size() > 0

    table_rows =  3
    
    // Create or recreate table if dimensions changed
    if na(info_table)
        info_table := table.new(helper.GetTablePosition(table_position), 1, table_rows, 
                               bgcolor=table_bg_color, 
                               border_width=table_border_width, 
                               border_color=table_border_color,
                               frame_width=table_frame_width,
                               frame_color=table_frame_color)
        current_table_rows := table_rows
    else
        // Check if we need to recreate table due to dimension change
        if current_table_rows != table_rows
            table.delete(info_table)
            info_table := table.new(helper.GetTablePosition(table_position), 1, table_rows, 
                                   bgcolor=table_bg_color, 
                                   border_width=table_border_width, 
                                   border_color=table_border_color,
                                   frame_width=table_frame_width,
                                   frame_color=table_frame_color)
            current_table_rows := table_rows
    
    // Table content
    title_text = helper.GetCurrentTimeframe() + "-" + helper.HTFName(htf1.settings.htf) + " Model"
    timer_text = helper.RemainingTime(htf1.settings.htf)
    
    // Get HTF bias using the last two closed candles
    bias_text = "Bias: Neutral"
    if htf1.candles.size() >= 3
        last_closed = htf1.candles.get(1)
        prev_closed = htf1.candles.get(2)
        bias_text := helper.GetHTFBias(last_closed, prev_closed)
    
    bias_and_time_text = bias_text
    
    // Set table cell content
    table.cell(info_table, 0, 0, title_text, 
               text_color=table_text_color, 
               text_size=table_size, 
               text_font_family=font.family_monospace,
               bgcolor=table_bg_color)
    
    table.cell(info_table, 0, 1, timer_text, 
               text_color=table_text_color, 
               text_size=table_size, 
               text_font_family=font.family_monospace,
               bgcolor=table_bg_color)
    
    table.cell(info_table, 0, 2, bias_and_time_text, 
               text_color=table_text_color, 
               text_size=table_size, 
               text_font_family=font.family_monospace,
               bgcolor=table_bg_color)
    
//HTF Candle End



// # ========================================================================= #
// # |   SWING POINTS     |
// # ========================================================================= #


string group_swing             = "Swing Points  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

showLiquidity = input.bool(true, title = "Show Liquidity Levels", group=group_swing)

// === HTF Settings CISD ===
htf_modesw = input.string("Auto", "HTF Mode", options=["Auto", "Manual"],group = group_swing)
htf_manualsw = input.timeframe("D", "Manual HTF Timeframe", tooltip="Only used in Manual mode",group = group_swing)

// Auto logic (fixed)
getAutoHTFsw() =>
    tf = timeframe.period
    result = tf == "1"     ? "15"  :
             tf == "3"     ? "30"  :
             tf == "5"     ? "60"  :
             (tf == "15" or tf == "30") ? "240" :
             tf == "60"    ? "D"   :
             tf == "240"   ? "W"   :
             tf == "1D"     ? "M"   :
             tf == "1W"     ? "3M"   :
             tf == "3W"     ? "12M"   :
             tf == "1M"     ? "12M"   :
             "D"
    result

// Select final HTF
htf_finalsw = htf_modesw == "Auto" ? getAutoHTFsw() : htf_manualsw


// ─── Settings ───
currentTF  = input.bool(false, title = "Swing Levels Current Timeframe", group=group_swing)
htfBool    = input.bool(true, title = "Swing Levels Higher Timeframe",inline="1", group=group_swing)
// htfTF     = input.timeframe("", title = "", inline="1",group=_tfSettings, tooltip="Display Liquidity Levels for a Higher Timeframe")
htfTF       = htf_finalsw


_lvlsGrp   = "Liquidity Levels"
leftBars   = input.int(1, title = "Left Bars", group=_lvlsGrp)
rightBars  = input.int(1, title = "Right Bars", group=_lvlsGrp)

_removeGrp = "Mitigation Settings"
removeMitigated = input.bool(true, title = "Remove Mitigated Levels", group=_removeGrp)
mitiOptions     = input.string("Show", title = "    ", options=["Remove", "Show"], group=_removeGrp)
_candleType     = input.string("Wick", title = "Candle type", options=["Close", "Wick"], group=_removeGrp)

_displayStyleGrp = "Display Styles"
extentionOptions = input.string("Current", title = "Extention Options", options=["Short", "Current", "Max"], group=_displayStyleGrp)
extentionMax     = extentionOptions=="Max"
extentionCurrent = extentionOptions=="Current"
displayLimit     = input.int(15, title = "Display Limit", group=_displayStyleGrp)

// ─── Line Styles ───
_styleGrp = "Line Styles and Colors"
_highLineStyle = input.string("Dotted", title = "High Line Style", options=["Solid", "Dashed", "Dotted"], group=_styleGrp)
highLineStyle  = _highLineStyle=="Solid" ? line.style_solid : _highLineStyle=="Dashed" ? line.style_dashed : line.style_dotted

_lowLineStyle  = input.string("Dotted", title = "Low Line Style", options=["Solid", "Dashed", "Dotted"], group=_styleGrp)
lowLineStyle   = _lowLineStyle=="Solid" ? line.style_solid : _lowLineStyle=="Dashed" ? line.style_dashed : line.style_dotted

lineWidth      = input.int(1, title = "Line Width", group=_styleGrp)
highLineColor  = input.color(#cccccc, "High Line", group = _styleGrp)
lowLineColor   = input.color(#cccccc, "Low Line", group = _styleGrp)

// HTF line styles
_styleGrpHTF = "Line Styles and Colors - Higher TimeFrame"
_highLineStyleHTF = input.string("Solid", title = "High Line HTF", options=["Solid", "Dashed", "Dotted"], group=_styleGrpHTF)
highLineStyleHTF  = _highLineStyleHTF=="Solid" ? line.style_solid : _highLineStyleHTF=="Dashed" ? line.style_dashed : line.style_dotted

_lowLineStyleHTF  = input.string("Solid", title = "Low Line HTF", options=["Solid", "Dashed", "Dotted"], group=_styleGrpHTF)
lowLineStyleHTF   = _lowLineStyleHTF=="Solid" ? line.style_solid : _lowLineStyleHTF=="Dashed" ? line.style_dashed : line.style_dotted

lineWidthHTF      = input.int(1, title = "Line Width HTF", group=_styleGrpHTF)
highLineColorHTF  = input.color(#f23645, "High Line HTF", group = _styleGrpHTF)
lowLineColorHTF   = input.color(#4caf50, "Low Line HTF", group = _styleGrpHTF)

// ─── Functions ───
tf_multi(tf) =>
    ts   = timeframe.in_seconds("")
    htfs = timeframe.in_seconds(tf)
    htfs / ts

display_limit_line(_array) =>
    if array.size(_array) > displayLimit/2
        a = array.shift(_array)
        line.delete(a)

remove_mitigated_lines(_array, _hl) =>
    if array.size(_array) > 0 and removeMitigated
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = _candleType == "Close" ? close[1] : high
            ll = _candleType == "Close" ? close[1] : low
            if _hl == "High" and hh > line.get_y1(l)
                array.remove(_array, i)
                if mitiOptions == "Show"
                    line.new(line.get_x1(l), line.get_y1(l), time, line.get_y1(l), xloc=xloc.bar_time, color=color.new(highLineColor, 70))
                line.delete(l)
            if _hl == "Low" and ll < line.get_y1(l)
                array.remove(_array, i)
                if mitiOptions == "Show"
                    line.new(line.get_x1(l), line.get_y1(l), time, line.get_y1(l), xloc=xloc.bar_time, color=color.new(lowLineColor, 70))
                line.delete(l)
    display_limit_line(_array)

extend_line_to_current(lineArray) =>
    if array.size(lineArray) > 0
        for i = 0 to array.size(lineArray) - 1
            l = array.get(lineArray, i)
            line.set_x2(l, time)   // extend to current bar

// ─── Arrays ───
var highLineArray = array.new_line()
var lowLineArray  = array.new_line()
var highLineArrayHTF = array.new_line()
var lowLineArrayHTF  = array.new_line()

// ─── Current TimeFrame ───
pivotHigh = ta.pivothigh(leftBars, rightBars)
pivotLow  = ta.pivotlow(leftBars, rightBars)

if showLiquidity and currentTF
    if not na(pivotHigh[1])
        array.push(highLineArray, line.new(time[rightBars+1], high[rightBars+1], time[1], high[rightBars+1], color=highLineColor, style=highLineStyle, xloc=xloc.bar_time, extend=extentionMax?extend.right:extend.none, width=lineWidth))
    if not na(pivotLow[1])
        array.push(lowLineArray, line.new(time[rightBars+1], low[rightBars+1], time[1], low[rightBars+1], color=lowLineColor, style=lowLineStyle, xloc=xloc.bar_time, extend=extentionMax?extend.right:extend.none, width=lineWidth))

if showLiquidity
    remove_mitigated_lines(highLineArray, "High")
    remove_mitigated_lines(lowLineArray, "Low")
    if extentionCurrent
        extend_line_to_current(highLineArray)
        extend_line_to_current(lowLineArray)

// ─── Higher TimeFrame ───
[_time, _open, _high, _low, _close] = request.security(syminfo.tickerid, htfTF, [time, open, high, low, close])

pivotHighHTF = ta.pivothigh(_high, leftBars*tf_multi(htfTF), rightBars+tf_multi(htfTF))
pivotLowHTF  = ta.pivotlow(_low, leftBars*tf_multi(htfTF), rightBars+tf_multi(htfTF))

if showLiquidity and htfBool
    dis = rightBars+tf_multi(htfTF)
    if not na(pivotHighHTF)
        array.push(highLineArrayHTF, line.new(_time[dis], _high[dis], _time[1], _high[dis], color=highLineColorHTF, style=highLineStyleHTF, xloc=xloc.bar_time, extend=extentionMax?extend.right:extend.none, width=lineWidthHTF))
    if not na(pivotLowHTF)
        array.push(lowLineArrayHTF, line.new(_time[dis], _low[dis], _time[1], _low[dis], color=lowLineColorHTF, style=lowLineStyleHTF, xloc=xloc.bar_time, extend=extentionMax?extend.right:extend.none, width=lineWidthHTF))

if showLiquidity
    remove_mitigated_lines(highLineArrayHTF, "High")
    remove_mitigated_lines(lowLineArrayHTF, "Low")
    if extentionCurrent
        extend_line_to_current(highLineArrayHTF)
        extend_line_to_current(lowLineArrayHTF)
